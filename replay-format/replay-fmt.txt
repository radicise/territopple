this document describes the format of the ".topl" territopple replay file

ALIGNMENT BYTE is a padding byte inserted only if alignment is not even

version 0:
BYTE - version
BYTE[8] - name of game (stored as indicies into the codeChars array)
...BYTE[2|4] - actions

actions take the following form
BYTE[2] - 0xf0,PLAYERNUMBER - player disconnect, eliminated from game, etc
BYTE[4] - duo 16bit int, move coordinates, row then column

version 1:
BYTE - version
BYTE[8] - name of game (ASCII plain text)
BYTE - flags <a-h> where a is MSB
- a (TIMESTAMP) - includes timestamps // timestamps can get big, best to give option of disabling them
- b+c (SIZE) - combine as a 2bit selector, 00 (tiny) is 36x36 max, 01 (medium) is 256x256 max, 10 (large) is 4096x4096 max, 11 (huge) is 2^16x2^16 max // allows further space savings
BYTE[8] - game start timestamp (ms since Jan 1, 1970 UTC) // this is nice and only adds constant cost
BYTE[2] - width
BYTE[2] - height
BYTE - player count
-- garbage data between the timestamp and start of game is to be ignored, and does not make a topl invalid --
BYTE[2] - 0xf0,0x0f - start of game data
...EVENT
BYTE[4] - 0xff,0xf0,0x0f,0xff - end of replay // allows multiple replays to be put into one file

EVENT:
BYTE (TYPE) - type of event
IF (TIMESTAMP) set:
    BYTE[2] - delta since previous timestamp (EXCEPTING if this is a TIMESTAMP event)
SWITCH (TYPE):
0 -> PLAYER ELIM: - player eliminated from turn order, reason not important
    BYTE - player number
1 -> PLAYER MOVE: - player moved
    SWITCH (SIZE):
        00 ->:
            BYTE[2] - R(5),C(5) the 6 bits on MSB side are reserved
        01 ->:
            BYTE[2] - R(8),C(8)
        10 ->:
            BYTE[3] - R(12),C(12)
        11 ->:
            BYTE[4] - R(16),C(16)
2 -> TIMESTAMP: - update the timestamp because nothing happened for over 18 hours
    BYTE[3] - delta time

version 2:
identical to version 1 with the following differences

...
BYTE - flags ...
...
- d (ORDER) - this flag is set if the turn order is NOT standard
...
BYTE - player count
IF (ORDER):
    BYTE (STRATEGY) - order determination strategy - valid values are:
    - 0 - each move has the player number recorded with it
    - 1 - players go in standard order, but a team map is provided
    BYTE (PADDING)
    FOR EACH player:
        BYTE - team assignment
    IF (player count) is odd:
        BYTE (PADDING)
BYTE[2] - 0xf0,0x0f
...
SWITCH (TYPE):
...
1 -> PLAYER MOVE: - player moved
    SWITCH (SIZE):
        00 ->:
            BYTE[2] - T(6),R(5),C(5) - player number, row, col
        01,10,11 ->:
            IF (ORDER):
                PREPEND BYTE - player number

version 3:
BYTE - version
BYTE[8] - name of game (ASCII plain text)
BYTE - flags <a-h> where a is MSB
- a (TIMESTAMP) - includes timestamps // timestamps can get big, best to give option of disabling them
- b+c (SIZE) - combine as a 2bit selector, 00 (tiny) is 1024 max, 01 (medium) is 2^18 max, 10 (large) is reserved, 11 (huge) is reserved // allows further space savings
- d (ORDER) - this flag is set if the turn order is NOT standard
- e (CTOPOLOGY) - this flag is set if the topology chosen is NOT standard
BYTE[8] - game start timestamp (ms since Jan 1, 1970 UTC) // this is nice and only adds constant cost
BYTE[4] - tile count
BYTE - player count
IF (ORDER):
    BYTE (STRATEGY) - order determination strategy - valid values are:
    - 0 - each move has the player number recorded with it
    - 1 - players go in standard order, but a team map is provided
    BYTE (PADDING)
    FOR EACH player:
        BYTE - team assignment
    IF (player count) is odd:
        BYTE (PADDING)
IF (CTOPOLOGY):
    IN PROGRESS
ELSE:
    BYTE[2] (TOPOLOGY) - topology scheme - valid values are:
    - 0 - 2d grid
    SWITCH (TOPOLOGY):
        0 ->:
            BYTE[2] - width (height is to be calculated as tile count / width)
    ALIGNMENT BYTE
-- garbage data between the timestamp and start of game is to be ignored, and does not make a topl invalid --
BYTE[2] - 0xf0,0x0f - start of game data
...EVENT
BYTE[4] - 0xff,0xf0,0x0f,0xff - end of replay // allows multiple replays to be put into one file

EVENT:
BYTE (TYPE) - type of event
IF (TIMESTAMP) set:
    BYTE[2] - delta since previous timestamp (EXCEPTING if this is a TIMESTAMP event)
SWITCH (TYPE):
0 -> PLAYER ELIM: - player eliminated from turn order, reason not important
    BYTE - player number
1 -> PLAYER MOVE: - player moved
    SWITCH (SIZE):
        00 ->:
            BYTE[2] - P(6),I(10)
        01 ->:
            BYTE[3] - P(6),I(18)
        10 ->:
            RESERVED
        11 ->:
            RESERVED
2 -> TIMESTAMP: - update the timestamp because nothing happened for over 18 hours
    BYTE[3] - delta time

version 4:
BYTE - version
BYTE[8] - name of game (ASCII plain text)
BYTE - flags <a-h> where a is MSB
- a (TIMESTAMP) - includes timestamps // timestamps can get big, best to give option of disabling them
- b+c (SIZE) - combine as a 2bit selector, 00 (tiny) is 32 & 7p max, 01 (medium) is 1024 & 63p max, 10 (large) is 2^16 & 255p max, 11 (huge) is 2^20 & 4095p max // allows further space savings
- d (ORDER) - this flag is set if the turn order is NOT standard
- e (CTOPOLOGY) - this flag is set if the topology chosen is NOT standard
BYTE[8] - game start timestamp (ms since Jan 1, 1970 UTC) // this is nice and only adds constant cost
BYTE[4] - tile count
BYTE - player count
IF (ORDER):
    BYTE (STRATEGY) - order determination strategy - valid values are:
    - 0 - each move has the player number recorded with it
    - 1 - players go in standard order, but a team map is provided
    ~~BYTE (PADDING)~~
    FOR EACH player:
        BYTE - team assignment
    IF (player count) is odd:
        BYTE (PADDING)
IF (CTOPOLOGY):
    INLINE TopologyRules
    BYTE[12] - 0xfe (repeat 12) - end marker
    BYTE[8] - 0xff, 0x33, 0x00, 0x55, 0x22, 0x88, 0x66, 0x44 - end marker
ELSE:
    BYTE[2] (TOPOLOGY) - topology scheme - valid values are:
    - 0 - 2d grid
    - 1 - 2d hwrap grid
    - 2 - 2d vwrap grid
    - 3 - 2d bwrap grid
    SWITCH (TOPOLOGY):
        0,1,2,3 ->:
            BYTE[2] - width (height is to be calculated as tile count / width)
ALIGNMENT BYTE
BYTE[8] - sequential game id
BYTE[16] - unique server fingerprint, derived from hostname, home directory, and machine type
-- garbage data between the timestamp and start of game is to be ignored, and does not make a topl invalid --
BYTE[2] - 0xf0,0x0f - start of game data
...EVENT
BYTE[4] - 0xff,0xf0,0x0f,0xff - end of replay // allows multiple replays to be put into one file

EVENT:
BYTE (TYPE) - type of event
IF (TIMESTAMP) set:
    BYTE[2] - delta since previous timestamp (EXCEPTING if this is a TIMESTAMP event)
SWITCH (TYPE):
0 -> PLAYER ELIM: - player eliminated from turn order, reason not important
    BYTE - player number
1 -> PLAYER MOVE: - player moved
    SWITCH (SIZE): NOTE: P bits are tile bits if ORDER is unset
        00 ->:
            BYTE[1] - P(3),I(5)
        01 ->:
            BYTE[2] - P(6),I(10)
        10 ->:
            BYTE[3] - P(8),I(16)
        11 ->:
            BYTE[4] - P(12),I(20)
2 -> TIMESTAMP: - update the timestamp because nothing happened for over 18 hours
    BYTE[3] - delta time

version 5:
BYTE - version
BYTE[8] - name of game (ASCII plain text)
BYTE - flags <a-h> where a is MSB
- a (TIMESTAMP) - includes timestamps // timestamps can get big, best to give option of disabling them
- b+c (SIZE) - combine as a 2bit selector, 00 (tiny) is 32 & 7p max, 01 (medium) is 1024 & 63p max, 10 (large) is 2^16 & 255p max, 11 (huge) is 2^20 & 4095p max // allows further space savings
- d (ORDER) - this flag is set if the turn order is NOT standard
- e (CTOPOLOGY) - this flag is set if the topology chosen is NOT standard
- f (EXTMETA) - this flag is set if the replay file contains extra metadata
- g (EXTEVS) - this flag is set if the replay file has extended the data in events
BYTE[8] - game start timestamp (ms since Jan 1, 1970 UTC) // this is nice and only adds constant cost
BYTE[4] - tile count
BYTE - player count
IF (ORDER):
    BYTE (STRATEGY) - order determination strategy - valid values are:
    - 0 - each move has the player number recorded with it
    - 1 - players go in standard order, but a team map is provided
    ~~BYTE (PADDING)~~
    FOR EACH player:
        BYTE - team assignment
    IF (player count) is odd:
        BYTE (PADDING)
IF (CTOPOLOGY):
    INLINE TopologyRules
    BYTE[12] - 0xfe (repeat 12) - end marker
    BYTE[8] - 0xff, 0x33, 0x00, 0x55, 0x22, 0x88, 0x66, 0x44 - end marker
ELSE:
    BYTE[2] (TOPOLOGY) - topology scheme - valid values are:
    - 0 - 2d grid
    - 1 - 2d hwrap grid
    - 2 - 2d vwrap grid
    - 3 - 2d bwrap grid
    SWITCH (TOPOLOGY):
        0,1,2,3 ->:
            BYTE[2] - width (height is to be calculated as tile count / width)
ALIGNMENT BYTE
BYTE[8] - sequential game id
BYTE[16] - unique server fingerprint, derived from hostname, home directory, and machine type

IF (EXTMETA):
    BYTE - extra flags count (EFC)
    BYTE[EFC] - extra flags
    BYTE[2] - metatable size (MTS)
    METATABLE_ENTRY[MTS] - metatable
IF (EXTEVS):
    BYTE - extended event count (EEVC)
    EVEXT_DESC[EEVC] - extended event descriptions

BYTE[2] - 0xf0,0x0f - start of game data
...EVENT
BYTE[4] - 0xff,0xf0,0x0f,0xff - end of replay // allows multiple replays to be put into one file

METATABLE_ENTRY:
BYTE[2] - value length [big endian] (VL)
BYTE[4] - key
BYTE[VL] - value
NOTE: select keys are reserved for specific purposes, see "./replay-mt-keys.txt"

EVEXT_DESC:
BYTE - event type that is extended (ID)
BYTE - extra field count (EV_EFC)
FIELD_DESCRIPTOR[EV_EFC] - extra fields
NOTE: if ID is defined in this format, these fields are APPENDED to the specified events

FIELD_DESCRIPTOR:
BIT - conditional flag (CFLAG)
IF (NOT CFLAG):
    BIT[7] - field size
ELSE:
    BIT[7] - flag byte
    BIT[3] - flag bit
    BIT[5] - field size

EVENT:
BYTE (TYPE) - type of event
IF (TIMESTAMP) set:
    BYTE[2] - delta since previous timestamp (EXCEPTING if this is a TIMESTAMP event)
SWITCH (TYPE):
0 -> PLAYER ELIM: - player eliminated from turn order, reason not important
    BYTE - player number
1 -> PLAYER MOVE: - player moved
    SWITCH (SIZE): NOTE: P bits are tile bits if ORDER is unset
        00 ->:
            BYTE[1] - P(3),I(5)
        01 ->:
            BYTE[2] - P(6),I(10)
        10 ->:
            BYTE[3] - P(8),I(16)
        11 ->:
            BYTE[4] - P(12),I(20)
2 -> TIMESTAMP: - update the timestamp because nothing happened for over 18 hours
    BYTE[3] - delta time

version 6:
BYTE - version
BYTE[8] - name of game (ASCII plain text)
BYTE - flags <a-h> where a is MSB
- a (TIMESTAMP) - includes timestamps // timestamps can get big, best to give option of disabling them
- b+c (SIZE) - combine as a 2bit selector, 00 (tiny) is 32 & 7p max, 01 (medium) is 1024 & 63p max, 10 (large) is 2^16 & 255p max, 11 (huge) is 2^20 & 4095p max // allows further space savings
- d (ORDER) - this flag is set if the turn order is NOT standard
- e (CTOPOLOGY) - this flag is set if the topology chosen is NOT standard
- f (EXTMETA) - this flag is set if the replay file contains extra metadata
- g (EXTEVS) - this flag is set if the replay file has extended the data in events
BYTE[8] - game start timestamp (ms since Jan 1, 1970 UTC) // this is nice and only adds constant cost
BYTE[4] - tile count
BYTE - player count
IF (ORDER):
    BYTE (STRATEGY) - order determination strategy - valid values are:
    - 0 - each move has the player number recorded with it
    - 1 - players go in standard order, but a team map is provided
    ~~BYTE (PADDING)~~
    FOR EACH player:
        BYTE - team assignment
    IF (player count) is odd:
        BYTE (PADDING)
IF (CTOPOLOGY):
    INLINE TopologyRules
    BYTE[12] - 0xfe (repeat 12) - end marker
    BYTE[8] - 0xff, 0x33, 0x00, 0x55, 0x22, 0x88, 0x66, 0x44 - end marker
ELSE:
    BYTE[2] (TOPOLOGY) - topology scheme - valid values are:
    - 0 - 2d grid
    - 1 - 2d hwrap grid
    - 2 - 2d vwrap grid
    - 3 - 2d bwrap grid
    SWITCH (TOPOLOGY):
        0,1,2,3 ->:
            BYTE[2] - width (height is to be calculated as tile count / width)
ALIGNMENT BYTE
BYTE[8] - sequential game id
BYTE[16] - unique server fingerprint, derived from hostname, home directory, and machine type

IF (EXTMETA):
    BYTE - extra flags count (EFC)
    BYTE[EFC] - extra flags
    BYTE[2] - metatable size (MTS)
    METATABLE_ENTRY[MTS] - metatable
IF (EXTEVS):
    BYTE - extended event count (EEVC)
    EVEXT_DESC[EEVC] - extended event descriptions

BYTE[2] - 0xf0,0x0f - start of game data
...EVENT
BYTE[4] - 0xff,0xf0,0x0f,0xff - end of replay // allows multiple replays to be put into one file

METATABLE_ENTRY:
BYTE[2] - value length [big endian] (VL)
BYTE[4] - key
BYTE[VL] - value
NOTE: select keys are reserved for specific purposes, see "./replay-mt-keys.txt"

EVEXT_DESC:
BYTE - event type that is extended (ID)
BYTE - extra field count (EV_EFC)
FIELD_DESCRIPTOR[EV_EFC] - extra fields
NOTE: if ID is defined in this format, these fields are APPENDED to the specified events
NOTE: EVENT ID 2 (timestamp) may NOT be extended
NOTE: EVENT ID 3 is reserved for use as an extended-only event, this and all future versions of this format will not
use event id 3 for any purpose

FIELD_DESCRIPTOR:
BYTE - NLEN
BYTE[NLEN] - field name
NOTE: replay files MUST NOT be generated in such a way that two fields within the same event have the same name
BIT - conditional flag (CFLAG)
IF (NOT CFLAG):
    BIT[7] - field size
ELSE:
    BIT - stdcond flag (SCFLAG)
    IF (SCFLAG):
        BIT[6] - flag byte
        BIT[3] - flag bit
        BIT[5] - field size
    ELSE:
        BIT[3] - offset (FOFF)
        BIT[3] - condition type (CTYPE)
        BYTE[sizeof(FIELD@FOFF)] - test value (VALUE)
        INTERPRET: this field is present iff the condition type is true for the comparison between
            the test value and the value of the field FOFF+1 fields before this field
        INTERPRET:
            CTYPE = 0 - ==
            CTYPE = 1 - !=
            CTYPE = 2 - >
            CTYPE = 3 - <
            CTYPE = 4 - >=
            CTYPE = 5 - <=
            CTYPE = 6 - FIELD%TEST == 0
            CTYPE = 7 - FIELD%TEST != 0
        BYTE - field size

EVENT:
BYTE (TYPE) - type of event
IF (TIMESTAMP) set:
    BYTE[2] - delta since previous timestamp (EXCEPTING if this is a TIMESTAMP event)
SWITCH (TYPE):
0 -> PLAYER ELIM: - player eliminated from turn order, reason not important
    BYTE - player number
1 -> PLAYER MOVE: - player moved
    SWITCH (SIZE): NOTE: P bits are tile bits if ORDER is unset
        00 ->:
            BYTE[1] - P(3),I(5)
        01 ->:
            BYTE[2] - P(6),I(10)
        10 ->:
            BYTE[3] - P(8),I(16)
        11 ->:
            BYTE[4] - P(12),I(20)
2 -> TIMESTAMP: - update the timestamp because nothing happened for over 18 hours
    BYTE[3] - delta time
